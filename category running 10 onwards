# Part 11: Callbacks (Basic Operations)

# Add keyboard shortcuts
app.clientside_callback(
    """
    function(n_intervals) {
        if (n_intervals === 1) {
            document.addEventListener('keydown', function(e) {
                // Ctrl+S for save
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    document.getElementById('save-btn').click();
                }
                // Ctrl+Z for undo
                if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    document.getElementById('undo-btn').click();
                }
                // Ctrl+Shift+Z for redo
                if (e.ctrlKey && e.shiftKey && e.key === 'z') {
                    e.preventDefault();
                    document.getElementById('redo-btn').click();
                }
                // Ctrl+E for export
                if (e.ctrlKey && e.key === 'e') {
                    e.preventDefault();
                    document.getElementById('export-btn').click();
                }
            });
        }
        return window.dash_clientside.no_update;
    }
    """,
    Output('keyboard-shortcuts', 'children'),
    Input('keyboard-interval', 'n_intervals')
)

# Update press options when row filter changes
@app.callback(
    Output("press-filter", "options"),
    Input("press-row-filter", "value")
)
def update_press_options(row_filter):
    return data_manager.get_press_options(row_filter)

# Toggle bulk mode
@app.callback(
    [Output("bulk-mode-active", "data"),
     Output("bulk-mode-btn", "children"),
     Output("bulk-actions", "style"),
     Output("bulk-actions", "children")],
    [Input("bulk-mode-btn", "n_clicks")],
    [State("bulk-mode-active", "data")]
)
def toggle_bulk_mode(n_clicks, is_active):
    if n_clicks == 0:
        raise PreventUpdate
    
    new_state = not is_active
    
    if new_state:
        btn_text = [html.Span("‚úì"), " Exit Bulk Mode"]
        actions_style = {"display": "block", "padding": "12px 20px", "backgroundColor": "#f8f9fa", "marginBottom": "12px"}
        actions_content = html.Div([
            html.Span("Bulk Actions: ", style={"fontWeight": "600", "marginRight": "12px"}),
            html.Button("Apply Template", id="bulk-apply-template", n_clicks=0, 
                       style={**BUTTON_STYLES["primary"], "marginRight": "8px"}),
            html.Div([
                dcc.Dropdown(
                    id="bulk-template-select",
                    options=[{"label": t["name"], "value": k} for k, t in QUICK_ALLOCATION_TEMPLATES.items()],
                    placeholder="Select template...",
                    style={"width": "200px", "marginRight": "8px"}
                )
            ], style={"display": "inline-block", "verticalAlign": "middle"})
        ], style={"display": "flex", "alignItems": "center"})
    else:
        btn_text = [html.Span("üî®"), " Bulk Mode"]
        actions_style = {"display": "none"}
        actions_content = None
    
    return new_state, btn_text, actions_style, actions_content

# Main table update - Removed data quality indicator
@app.callback(
    [Output("table-container", "children"),
     Output("shift-info", "children"),
     Output("event-count", "children"),
     Output("allocation-summary", "children"),
     Output("alerts", "children"),
     Output("data-version", "data"),
     Output("current-filters", "data")],
    [Input("datetime-start", "value"),
     Input("datetime-end", "value"),
     Input("press-row-filter", "value"),
     Input("press-filter", "value"),
     Input("duration-filter", "value"),
     Input("event-status-filter", "value"),
     Input("refresh-btn", "n_clicks"),
     Input("data-version", "data"),
     Input("bulk-mode-active", "data")]
)
def update_table(start_date, end_date, press_row, press_ids, duration_threshold, 
                event_status, refresh_clicks, data_version, bulk_mode):
    
    # Get filtered data
    df = data_manager.get_filtered_data(
        start_date, end_date, press_row, press_ids, 
        duration_threshold, event_status
    )
    
    # Build table
    table = build_table(df, bulk_mode)
    
    # Shift info
    if start_date and end_date:
        start_dt = pd.to_datetime(start_date)
        end_dt = pd.to_datetime(end_date)
        _, _, shift = get_shift_from_datetime(start_dt)
        shift_config = CONFIG["shifts"].get(shift, {})
        shift_info = f"üïê {shift_config.get('name', 'Unknown')} | {start_dt.strftime('%m/%d %H:%M')} - {end_dt.strftime('%H:%M')}"
    else:
        shift_info = "üïê No date range selected"
    
    # Event count
    total_events = len(df)
    ongoing_events = len(df[df['parsed_end'] == pd.Timestamp.max]) if 'parsed_end' in df.columns else 0
    event_count = f"üìä Events: {total_events} total | {ongoing_events} ongoing"
    
    # Allocation summary
    summary = data_manager.get_allocation_summary()
    if summary:
        allocation_summary = (
            f"üìà Allocated: {summary['fully_allocated']}/{summary['total_events']} complete | "
            f"{summary['overall_allocation_percentage']:.0f}% time coverage"
        )
    else:
        allocation_summary = "üìà No allocation data"
    
    # Alerts
    alerts = []
    if data_manager.pending_changes:
        alerts.append(
            html.Div([
                html.Span("‚ö†Ô∏è", style={"fontSize": "16px", "marginRight": "8px"}),
                "Unsaved changes - Press Ctrl+S to save"
            ], style={
                "backgroundColor": "#fff3cd",
                "color": "#856404",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
        )
    
    # Store current filters
    current_filters = {
        "start_date": start_date,
        "end_date": end_date,
        "press_row": press_row,
        "press_ids": press_ids,
        "duration_threshold": duration_threshold,
        "event_status": event_status
    }
    
    return table, shift_info, event_count, allocation_summary, alerts, data_manager.data_version, current_filters

# Handle comment updates
@app.callback(
    Output("data-version", "data", allow_duplicate=True),
    [Input({"type": "comment", "index": ALL}, "value")],
    [State({"type": "comment", "index": ALL}, "id")],
    prevent_initial_call=True
)
def handle_comment_updates(comments, comment_ids):
    if not ctx.triggered:
        raise PreventUpdate
    
    # Find which comment was changed
    changed_id = ctx.triggered[0]['prop_id'].split('.')[0]
    comment_index = json.loads(changed_id)['index']
    
    # Get the new comment value
    for i, comment_id in enumerate(comment_ids):
        if comment_id['index'] == comment_index:
            new_comment = comments[i]
            break
    else:
        raise PreventUpdate
    
    # Update the data
    data_manager.update_data(comment_index, "Comment", new_comment, f"Updated comment for {comment_index}")
    
    return data_manager.data_version

# Handle shift navigation
@app.callback(
    [Output("datetime-start", "value"),
     Output("datetime-end", "value")],
    [Input("prev-shift-btn", "n_clicks"),
     Input("current-shift-btn", "n_clicks"),
     Input("next-shift-btn", "n_clicks")],
    [State("datetime-start", "value")]
)
def handle_shift_navigation(prev_clicks, current_clicks, next_clicks, current_start):
    if not ctx.triggered:
        raise PreventUpdate
    
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    
    if button_id == "current-shift-btn":
        start, end, _ = get_current_shift_range()
    else:
        current_dt = pd.to_datetime(current_start) if current_start else datetime.datetime.now()
        
        if button_id == "prev-shift-btn":
            start, end, _ = get_previous_shift(current_dt)
        elif button_id == "next-shift-btn":
            start, end, _ = get_next_shift(current_dt)
        else:
            raise PreventUpdate
    
    return start.strftime("%Y-%m-%dT%H:%M"), end.strftime("%Y-%m-%dT%H:%M")

# Handle save button
@app.callback(
    Output("alerts", "children", allow_duplicate=True),
    Input("save-btn", "n_clicks"),
    prevent_initial_call=True
)
def handle_save(n_clicks):
    if n_clicks == 0:
        raise PreventUpdate
    
    if data_manager.safe_save_with_rollback():
        return html.Div([
            html.Span("‚úì", style={"fontSize": "16px", "marginRight": "8px"}),
            f"Saved successfully at {datetime.datetime.now().strftime('%H:%M:%S')}"
        ], style={
            "backgroundColor": "#d4edda",
            "color": "#155724",
            "padding": "8px 12px",
            "borderRadius": "4px",
            "fontSize": "13px",
            "display": "inline-flex",
            "alignItems": "center"
        })
    else:
        return html.Div([
            html.Span("‚ùå", style={"fontSize": "16px", "marginRight": "8px"}),
            "Save failed - data rolled back"
        ], style={
            "backgroundColor": "#f8d7da",
            "color": "#721c24",
            "padding": "8px 12px",
            "borderRadius": "4px",
            "fontSize": "13px",
            "display": "inline-flex",
            "alignItems": "center"
        })

# Handle undo/redo
@app.callback(
    [Output("data-version", "data", allow_duplicate=True),
     Output("alerts", "children", allow_duplicate=True)],
    [Input("undo-btn", "n_clicks"),
     Input("redo-btn", "n_clicks")],
    prevent_initial_call=True
)
def handle_undo_redo(undo_clicks, redo_clicks):
    if not ctx.triggered:
        raise PreventUpdate
    
    button_id = ctx.triggered[0]['prop_id'].split('.')[0]
    
    if button_id == "undo-btn":
        if data_manager.undo():
            return data_manager.data_version, html.Div([
                html.Span("‚Ü©", style={"fontSize": "16px", "marginRight": "8px"}),
                "Undo successful"
            ], style={
                "backgroundColor": "#cfe2ff",
                "color": "#084298",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
        else:
            return data_manager.data_version, html.Div([
                html.Span("‚Ñπ", style={"fontSize": "16px", "marginRight": "8px"}),
                "Nothing to undo"
            ], style={
                "backgroundColor": "#f8d7da",
                "color": "#721c24",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
    
    elif button_id == "redo-btn":
        if data_manager.redo():
            return data_manager.data_version, html.Div([
                html.Span("‚Ü™", style={"fontSize": "16px", "marginRight": "8px"}),
                "Redo successful"
            ], style={
                "backgroundColor": "#cfe2ff",
                "color": "#084298",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
        else:
            return data_manager.data_version, html.Div([
                html.Span("‚Ñπ", style={"fontSize": "16px", "marginRight": "8px"}),
                "Nothing to redo"
            ], style={
                "backgroundColor": "#f8d7da",
                "color": "#721c24",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
    
    raise PreventUpdate
# Part 12: Callbacks (Modal Operations and Final)

# Handle modal open/close with button position tracking
@app.callback(
    [Output("allocation-modal", "style"),
     Output("modal-backdrop", "style"),
     Output("modal-event-key", "data"),
     Output("modal-title", "children"),
     Output("modal-event-info", "children"),
     Output("modal-duration-info", "children"),
     Output("modal-current-allocations", "children"),
     Output("modal-progress-text", "children"),
     Output("modal-progress-fill", "style"),
     Output("modal-category-dropdown", "options"),
     Output("modal-duration-input", "max"),
     Output("modal-remaining-time", "children"),
     Output("modal-temp-allocations", "data"),
     Output("modal-button-position", "data")],
    [Input({"type": "open-modal-btn", "index": ALL}, "n_clicks"),
     Input("close-modal", "n_clicks"),
     Input("modal-cancel-btn", "n_clicks")],
    [State({"type": "open-modal-btn", "index": ALL}, "id")]
)
def handle_modal_display(open_clicks, close_clicks, cancel_clicks, button_ids):
    if not ctx.triggered:
        raise PreventUpdate
    
    triggered_id = ctx.triggered[0]['prop_id']
    
    # Handle close or cancel
    if "close-modal" in triggered_id or "modal-cancel-btn" in triggered_id:
        return ({"display": "none"}, {"display": "none"}, None, "", "", "", [], "", 
                {"width": "0%", "height": "8px", "backgroundColor": "#27ae60", 
                 "borderRadius": "4px", "transition": "width 0.3s ease"}, 
                [], 0, "", {}, {})
    
    # Handle open
    if any(open_clicks):
        changed_id = ctx.triggered[0]['prop_id'].split('.')[0]
        event_key = json.loads(changed_id)['index']
        
        # Get event data
        event_data = data_manager.get_event_data(event_key)
        if not event_data:
            raise PreventUpdate
        
        total_duration = event_data['total_duration']
        cat_durations = event_data['category_durations']
        allocated_duration = sum(cat_durations.values())
        remaining_duration = total_duration - allocated_duration
        allocation_percentage = (allocated_duration / total_duration * 100) if total_duration > 0 else 0
        
        # Create current allocations display
        allocation_items = []
        for cat_code, duration in cat_durations.items():
            cat_info = next((c for c in EVENT_CATEGORIES if c["value"] == cat_code), None)
            if cat_info:
                item = html.Div([
                    html.Div([
                        html.Span("", style={
                            "display": "inline-block",
                            "width": "16px",
                            "height": "16px",
                            "backgroundColor": cat_info["color"],
                            "borderRadius": "4px",
                            "marginRight": "12px"
                        }),
                        html.Span(f"{cat_info['icon']} {cat_info['label']}", style={
                            "fontWeight": "500",
                            "flex": "1",
                            "fontSize": "14px"
                        }),
                        html.Span(format_minutes(duration), style={
                            "marginRight": "12px",
                            "color": "#7f8c8d",
                            "fontSize": "14px"
                        }),
                        html.Button("Remove", 
                                   id={"type": "modal-remove-category", "category": cat_code},
                                   n_clicks=0,
                                   style={**BUTTON_STYLES["warning"], "fontSize": "12px", "padding": "4px 10px"})
                    ], style={
                        "display": "flex",
                        "alignItems": "center",
                        "padding": "8px",
                        "backgroundColor": "#f8f9fa",
                        "borderRadius": "4px",
                        "marginBottom": "8px"
                    })
                ])
                allocation_items.append(item)
        
        if not allocation_items:
            allocation_items = [html.Div("No categories allocated yet", 
                                       style={"color": "#95a5a6", "fontStyle": "italic", "padding": "20px", "textAlign": "center"})]
        
        # Available categories
        allocated_codes = list(cat_durations.keys())
        available_categories = [
            {"label": f"{cat['icon']} {cat['label']}", "value": cat["value"]} 
            for cat in EVENT_CATEGORIES if cat["value"] not in allocated_codes
        ]
        
        # Progress bar color
        progress_color = "#27ae60" if allocation_percentage >= 100 else "#f39c12" if allocation_percentage >= 50 else "#e74c3c"
        
        # Event info
        event_info = f"Press: {event_data['press_id']} | Started: {event_data['start_time'].strftime('%m/%d %H:%M') if hasattr(event_data['start_time'], 'strftime') else 'N/A'}"
        if event_data['is_ongoing']:
            event_info += " | Status: üî¥ Ongoing"
        
        # Modal position - next to button
        modal_style = {
            "position": "fixed",
            "right": "20px",  # Position from right edge
            "top": "50%",
            "transform": "translateY(-50%)",  # Center vertically
            "zIndex": "2000",
            "display": "block"
        }
        
        return (
            modal_style,
            {"display": "block"},
            event_key,
            f"Category Allocation - {event_key}",
            event_info,
            f"Total Duration: {format_minutes(total_duration)}",
            allocation_items,
            f"Allocation Progress: {allocation_percentage:.0f}% ({format_minutes(allocated_duration)} of {format_minutes(total_duration)})",
            {"width": f"{min(allocation_percentage, 100)}%", "height": "8px", "backgroundColor": progress_color, 
             "borderRadius": "4px", "transition": "width 0.3s ease"},
            available_categories,
            remaining_duration,
            f"‚è±Ô∏è Remaining: {format_minutes(remaining_duration)}",
            cat_durations,
            {}
        )
    
    raise PreventUpdate

# Handle template application in modal
@app.callback(
    Output("modal-temp-allocations", "data", allow_duplicate=True),
    [Input({"type": "template-btn", "template": ALL}, "n_clicks")],
    [State("modal-event-key", "data"),
     State({"type": "template-btn", "template": ALL}, "id")],
    prevent_initial_call=True
)
def handle_template_click(n_clicks_list, event_key, template_ids):
    if not any(n_clicks_list) or not event_key:
        raise PreventUpdate
    
    # Find which template was clicked
    for i, n_clicks in enumerate(n_clicks_list):
        if n_clicks > 0:
            template_key = template_ids[i]['template']
            break
    else:
        raise PreventUpdate
    
    # Get event data
    event_data = data_manager.get_event_data(event_key)
    if not event_data:
        raise PreventUpdate
    
    # Apply template
    template = QUICK_ALLOCATION_TEMPLATES[template_key]
    total_duration = event_data['total_duration']
    
    new_allocations = {
        cat: total_duration * percentage 
        for cat, percentage in template['allocations'].items()
    }
    
    return new_allocations

# Handle adding category in modal
@app.callback(
    [Output("modal-temp-allocations", "data", allow_duplicate=True),
     Output("modal-current-allocations", "children", allow_duplicate=True),
     Output("modal-progress-text", "children", allow_duplicate=True),
     Output("modal-progress-fill", "style", allow_duplicate=True),
     Output("modal-category-dropdown", "options", allow_duplicate=True),
     Output("modal-duration-input", "max", allow_duplicate=True),
     Output("modal-remaining-time", "children", allow_duplicate=True),
     Output("modal-category-dropdown", "value"),
     Output("modal-duration-input", "value")],
    [Input("modal-add-btn", "n_clicks")],
    [State("modal-category-dropdown", "value"),
     State("modal-duration-input", "value"),
     State("modal-event-key", "data"),
     State("modal-temp-allocations", "data")],
    prevent_initial_call=True
)
def handle_modal_add_category(n_clicks, category, duration, event_key, temp_allocations):
    if not n_clicks or not category or not duration or not event_key:
        raise PreventUpdate
    
    # Get event data
    event_data = data_manager.get_event_data(event_key)
    if not event_data:
        raise PreventUpdate
        
    total_duration = event_data['total_duration']
    
    # Update temp allocations
    if not temp_allocations:
        temp_allocations = {}
    
    temp_allocations[category] = temp_allocations.get(category, 0) + duration
    
    # Calculate new totals
    allocated_duration = sum(temp_allocations.values())
    remaining_duration = total_duration - allocated_duration
    allocation_percentage = (allocated_duration / total_duration * 100) if total_duration > 0 else 0
    
    # Create updated allocations display
    allocation_items = []
    for cat_code, dur in temp_allocations.items():
        cat_info = next((c for c in EVENT_CATEGORIES if c["value"] == cat_code), None)
        if cat_info:
            item = html.Div([
                html.Div([
                    html.Span("", style={
                        "display": "inline-block",
                        "width": "16px",
                        "height": "16px",
                        "backgroundColor": cat_info["color"],
                        "borderRadius": "4px",
                        "marginRight": "12px"
                    }),
                    html.Span(f"{cat_info['icon']} {cat_info['label']}", style={
                        "fontWeight": "500",
                        "flex": "1",
                        "fontSize": "14px"
                    }),
                    html.Span(format_minutes(dur), style={
                        "marginRight": "12px",
                        "color": "#7f8c8d",
                        "fontSize": "14px"
                    }),
                    html.Button("Remove", 
                               id={"type": "modal-remove-category", "category": cat_code},
                               n_clicks=0,
                               style={**BUTTON_STYLES["warning"], "fontSize": "12px", "padding": "4px 10px"})
                ], style={
                    "display": "flex",
                    "alignItems": "center",
                    "padding": "8px",
                    "backgroundColor": "#f8f9fa",
                    "borderRadius": "4px",
                    "marginBottom": "8px"
                })
            ])
            allocation_items.append(item)
    
    # Available categories
    allocated_codes = list(temp_allocations.keys())
    available_categories = [
        {"label": f"{cat['icon']} {cat['label']}", "value": cat["value"]} 
        for cat in EVENT_CATEGORIES if cat["value"] not in allocated_codes
    ]
    
    # Progress bar color
    progress_color = "#27ae60" if allocation_percentage >= 100 else "#f39c12" if allocation_percentage >= 50 else "#e74c3c"
    
    return (
        temp_allocations,
        allocation_items,
        f"Allocation Progress: {allocation_percentage:.0f}% ({format_minutes(allocated_duration)} of {format_minutes(total_duration)})",
        {"width": f"{min(allocation_percentage, 100)}%", "height": "8px", "backgroundColor": progress_color, 
         "borderRadius": "4px", "transition": "width 0.3s ease"},
        available_categories,
        max(0, remaining_duration),
        f"‚è±Ô∏è Remaining: {format_minutes(max(0, remaining_duration))}",
        None,  # Clear dropdown
        None   # Clear input
    )

# Handle removing category in modal
@app.callback(
    [Output("modal-temp-allocations", "data", allow_duplicate=True),
     Output("modal-current-allocations", "children", allow_duplicate=True),
     Output("modal-progress-text", "children", allow_duplicate=True),
     Output("modal-progress-fill", "style", allow_duplicate=True),
     Output("modal-category-dropdown", "options", allow_duplicate=True),
     Output("modal-duration-input", "max", allow_duplicate=True),
     Output("modal-remaining-time", "children", allow_duplicate=True)],
    [Input({"type": "modal-remove-category", "category": ALL}, "n_clicks")],
    [State("modal-event-key", "data"),
     State("modal-temp-allocations", "data")],
    prevent_initial_call=True
)
def handle_modal_remove_category(n_clicks_list, event_key, temp_allocations):
    if not any(n_clicks_list) or not event_key:
        raise PreventUpdate
    
    # Find which button was clicked
    triggered_id = ctx.triggered[0]['prop_id'].split('.')[0]
    category_to_remove = json.loads(triggered_id)['category']
    
    # Get event data
    event_data = data_manager.get_event_data(event_key)
    if not event_data:
        raise PreventUpdate
        
    total_duration = event_data['total_duration']
    
    # Remove from temp allocations
    if temp_allocations and category_to_remove in temp_allocations:
        del temp_allocations[category_to_remove]
    
    # Calculate new totals
    allocated_duration = sum(temp_allocations.values()) if temp_allocations else 0
    remaining_duration = total_duration - allocated_duration
    allocation_percentage = (allocated_duration / total_duration * 100) if total_duration > 0 else 0
    
    # Create updated allocations display
    allocation_items = []
    if temp_allocations:
        for cat_code, dur in temp_allocations.items():
            cat_info = next((c for c in EVENT_CATEGORIES if c["value"] == cat_code), None)
            if cat_info:
                item = html.Div([
                    html.Div([
                        html.Span("", style={
                            "display": "inline-block",
                            "width": "16px",
                            "height": "16px",
                            "backgroundColor": cat_info["color"],
                            "borderRadius": "4px",
                            "marginRight": "12px"
                        }),
                        html.Span(f"{cat_info['icon']} {cat_info['label']}", style={
                            "fontWeight": "500",
                            "flex": "1",
                            "fontSize": "14px"
                        }),
                        html.Span(format_minutes(dur), style={
                            "marginRight": "12px",
                            "color": "#7f8c8d",
                            "fontSize": "14px"
                        }),
                        html.Button("Remove", 
                                   id={"type": "modal-remove-category", "category": cat_code},
                                   n_clicks=0,
                                   style={**BUTTON_STYLES["warning"], "fontSize": "12px", "padding": "4px 10px"})
                    ], style={
                        "display": "flex",
                        "alignItems": "center",
                        "padding": "8px",
                        "backgroundColor": "#f8f9fa",
                        "borderRadius": "4px",
                        "marginBottom": "8px"
                    })
                ])
                allocation_items.append(item)
    else:
        allocation_items = [html.Div("No categories allocated yet", 
                                   style={"color": "#95a5a6", "fontStyle": "italic", "padding": "20px", "textAlign": "center"})]
    
    # Available categories
    allocated_codes = list(temp_allocations.keys()) if temp_allocations else []
    available_categories = [
        {"label": f"{cat['icon']} {cat['label']}", "value": cat["value"]} 
        for cat in EVENT_CATEGORIES if cat["value"] not in allocated_codes
    ]
    
    # Progress bar color
    progress_color = "#27ae60" if allocation_percentage >= 100 else "#f39c12" if allocation_percentage >= 50 else "#e74c3c"
    
    return (
        temp_allocations or {},
        allocation_items,
        f"Allocation Progress: {allocation_percentage:.0f}% ({format_minutes(allocated_duration)} of {format_minutes(total_duration)})",
        {"width": f"{min(allocation_percentage, 100)}%", "height": "8px", "backgroundColor": progress_color, 
         "borderRadius": "4px", "transition": "width 0.3s ease"},
        available_categories,
        remaining_duration,
        f"‚è±Ô∏è Remaining: {format_minutes(remaining_duration)}"
    )

# Handle saving modal changes
@app.callback(
    [Output("data-version", "data", allow_duplicate=True),
     Output("allocation-modal", "style", allow_duplicate=True),
     Output("modal-backdrop", "style", allow_duplicate=True),
     Output("alerts", "children", allow_duplicate=True)],
    [Input("modal-save-btn", "n_clicks")],
    [State("modal-event-key", "data"),
     State("modal-temp-allocations", "data")],
    prevent_initial_call=True
)
def handle_modal_save(n_clicks, event_key, temp_allocations):
    if not n_clicks or not event_key:
        raise PreventUpdate
    
    try:
        # Update the data
        data_manager.update_category_durations(event_key, temp_allocations or {}, f"Updated allocations for {event_key}")
        
        # Close modal
        return (
            data_manager.data_version,
            {"display": "none"},
            {"display": "none"},
            html.Div([
                html.Span("‚úì", style={"fontSize": "16px", "marginRight": "8px"}),
                f"Updated allocations for {event_key}"
            ], style={
                "backgroundColor": "#d4edda",
                "color": "#155724",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
        )
    except Exception as e:
        # Show error but don't close modal
        return (
            data_manager.data_version,
            {"display": "block"},
            {"display": "block"},
            html.Div([
                html.Span("‚ùå", style={"fontSize": "16px", "marginRight": "8px"}),
                str(e)
            ], style={
                "backgroundColor": "#f8d7da",
                "color": "#721c24",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
        )

# Handle validation
@app.callback(
    Output("validation-results", "children"),
    Input("validate-btn", "n_clicks"),
    prevent_initial_call=True
)
def handle_validation(n_clicks):
    if n_clicks == 0:
        raise PreventUpdate
    
    validation_messages = data_manager.validate_durations()
    
    if not validation_messages:
        return html.Div([
            html.Div([
                html.Span("‚úì", style={"fontSize": "20px", "marginRight": "8px"}),
                "All allocations are valid!"
            ], style={
                "display": "flex",
                "alignItems": "center",
                "fontSize": "14px",
                "fontWeight": "500"
            })
        ], style={
            "backgroundColor": "#d4edda",
            "color": "#155724",
            "padding": "12px 16px",
            "borderRadius": "4px",
            "marginBottom": "12px"
        })
    
    # Group messages by type
    errors = [msg for msg in validation_messages if msg.startswith("‚ùå")]
    warnings = [msg for msg in validation_messages if msg.startswith("‚ö†Ô∏è")]
    
    # Limit displayed messages
    max_display = 10
    display_content = []
    
    if errors:
        display_content.append(
            html.Div([
                html.H6(f"Errors ({len(errors)})", style={"margin": "0 0 8px 0", "color": "#721c24"}),
                html.Div([
                    html.Div(error, style={"fontSize": "12px", "marginBottom": "4px"})
                    for error in errors[:max_display]
                ]),
                html.Div(f"... and {len(errors) - max_display} more", 
                        style={"fontSize": "11px", "fontStyle": "italic", "color": "#721c24"})
                if len(errors) > max_display else None
            ])
        )
    
    if warnings:
        display_content.append(
            html.Div([
                html.H6(f"Warnings ({len(warnings)})", style={"margin": "12px 0 8px 0", "color": "#856404"}),
                html.Div([
                    html.Div(warning, style={"fontSize": "12px", "marginBottom": "4px"})
                    for warning in warnings[:max_display]
                ]),
                html.Div(f"... and {len(warnings) - max_display} more", 
                        style={"fontSize": "11px", "fontStyle": "italic", "color": "#856404"})
                if len(warnings) > max_display else None
            ])
        )
    
    return html.Div(display_content, style={
        "backgroundColor": "#fff3cd" if not errors else "#f8d7da",
        "padding": "12px 16px",
        "borderRadius": "4px",
        "marginBottom": "12px",
        "maxHeight": "300px",
        "overflowY": "auto"
    })

# Handle export
@app.callback(
    Output("download-dataframe-csv", "data"),
    Input("export-btn", "n_clicks"),
    [State("current-filters", "data")],
    prevent_initial_call=True
)
def handle_export(n_clicks, filters):
    if n_clicks == 0:
        raise PreventUpdate
    
    # Re-apply filters to get current view
    if filters:
        df = data_manager.get_filtered_data(
            filters.get("start_date"),
            filters.get("end_date"),
            filters.get("press_row"),
            filters.get("press_ids"),
            filters.get("duration_threshold"),
            filters.get("event_status")
        )
    else:
        df = data_manager.view_df
    
    if df is None or df.empty:
        raise PreventUpdate
    
    # Prepare export dataframe
    export_df = df.copy()
    
    # Add readable columns
    export_df['Is_Ongoing'] = export_df['parsed_end'].apply(
        lambda x: 'Yes' if x == pd.Timestamp.max else 'No'
    )
    
    export_df['Event_Status'] = export_df.get('shift_status', 'current').apply(
        lambda x: 'Carryover' if x == 'carryover' else 'Current'
    )
    
    export_df['Allocation_Status'] = export_df.apply(
        lambda row: 'Fully Allocated' if row.get('Allocation_Percentage', 0) >= 100 
        else 'Partially Allocated' if row.get('Allocation_Percentage', 0) > 0 
        else 'Unallocated',
        axis=1
    )
    
    # Remove internal columns
    internal_cols = ['parsed_start', 'parsed_end', 'shift_status', 
                    'Duration_Display', 'has_allocation', '_parsed_start', '_parsed_end']
    export_cols = [col for col in export_df.columns if col not in internal_cols]
    
    # Reorder columns for better readability
    priority_cols = ['Press_ID', 'StartTime EST', 'EndTime EST', 'Duration', 
                    'Calculated_Duration', 'Categories', 'Category_Durations', 
                    'Comment', 'Is_Ongoing', 'Event_Status', 'Allocation_Status',
                    'Allocated_Duration', 'Remaining_Duration', 'Allocation_Percentage']
    
    final_cols = [col for col in priority_cols if col in export_cols]
    remaining_cols = [col for col in export_cols if col not in final_cols]
    
    export_df = export_df[final_cols + remaining_cols]
    
    # Add timestamp to filename
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"event_categorization_{timestamp}.csv"
    
    return dcc.send_data_frame(export_df.to_csv, filename, index=False)

# Handle bulk template application
@app.callback(
    [Output("alerts", "children", allow_duplicate=True),
     Output("data-version", "data", allow_duplicate=True)],
    [Input("bulk-apply-template", "n_clicks")],
    [State("bulk-template-select", "value"),
     State("selected-events", "data")],
    prevent_initial_call=True
)
def handle_bulk_template_apply(n_clicks, template_key, selected_events):
    if not n_clicks or not template_key or not selected_events:
        raise PreventUpdate
    
    success_count, errors = data_manager.bulk_update_category_durations(selected_events, template_key)
    
    if success_count > 0:
        message = f"‚úì Applied template to {success_count} events"
        if errors:
            message += f" ({len(errors)} errors)"
        
        return html.Div([
            html.Span("‚úì", style={"fontSize": "16px", "marginRight": "8px"}),
            message
        ], style={
            "backgroundColor": "#d4edda",
            "color": "#155724",
            "padding": "8px 12px",
            "borderRadius": "4px",
            "fontSize": "13px",
            "display": "inline-flex",
            "alignItems": "center"
        }), data_manager.data_version
    else:
        return html.Div([
            html.Span("‚ùå", style={"fontSize": "16px", "marginRight": "8px"}),
            "Failed to apply template"
        ], style={
            "backgroundColor": "#f8d7da",
            "color": "#721c24",
            "padding": "8px 12px",
            "borderRadius": "4px",
            "fontSize": "13px",
            "display": "inline-flex",
            "alignItems": "center"
        }), data_manager.data_version

# Handle event selection for bulk mode
@app.callback(
    Output("selected-events", "data"),
    [Input({"type": "event-select", "index": ALL}, "value"),
     Input("select-all-events", "value")],
    [State({"type": "event-select", "index": ALL}, "id")],
    prevent_initial_call=True
)
def handle_event_selection(individual_selections, select_all, event_ids):
    if ctx.triggered[0]['prop_id'] == 'select-all-events.value':
        if "all" in select_all:
            # Select all events
            return [event_id['index'] for event_id in event_ids]
        else:
            # Deselect all
            return []
    else:
        # Individual selection
        selected = []
        for i, selection in enumerate(individual_selections):
            if selection:
                selected.extend(selection)
        return selected

# Auto-refresh
@app.callback(
    Output("data-version", "data", allow_duplicate=True),
    Input("auto-refresh", "n_intervals"),
    prevent_initial_call=True
)
def auto_refresh(n_intervals):
    print(f"Auto-refresh triggered at {datetime.datetime.now()}")
    if data_manager.load_data():
        return data_manager.data_version
    raise PreventUpdate

# Auto-save
@app.callback(
    Output("alerts", "children", allow_duplicate=True),
    Input("auto-save", "n_intervals"),
    prevent_initial_call=True
)
def auto_save(n_intervals):
    if data_manager.pending_changes:
        if data_manager.safe_save_with_rollback():
            print(f"Auto-save successful at {datetime.datetime.now()}")
            return html.Div([
                html.Span("üíæ", style={"fontSize": "16px", "marginRight": "8px"}),
                f"Auto-saved at {datetime.datetime.now().strftime('%H:%M:%S')}"
            ], style={
                "backgroundColor": "#d1ecf1",
                "color": "#0c5460",
                "padding": "8px 12px",
                "borderRadius": "4px",
                "fontSize": "13px",
                "display": "inline-flex",
                "alignItems": "center"
            })
    raise PreventUpdate

# =============================================================================
# End of Application
# =============================================================================
print("\n" + "="*60)
print("‚úÖ Enhanced application setup complete!")
print(f"üìÖ Current Date/Time: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC")
print("üöÄ Key improvements implemented:")
print("   ‚Ä¢ Modal now appears on the right side of screen")
print("   ‚Ä¢ Removed data quality indicator and calculations")
print("   ‚Ä¢ Enhanced modal with templates")
print("   ‚Ä¢ Improved error handling")
print("   ‚Ä¢ Bulk operations support")
print("   ‚Ä¢ Better visual feedback")
print("   ‚Ä¢ Keyboard shortcuts (Ctrl+S, Ctrl+Z, etc.)")
print("   ‚Ä¢ Smart validation")
print("   ‚Ä¢ All styling done inline (no html.Style)")
print("="*60 + "\n")

# Run the app if this is the main script
